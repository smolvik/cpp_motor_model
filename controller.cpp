#include <stdint.h>
#include "gdef.h"
#include "filter.h"

#define MY_PI 512
#define USE_SVPWM
#define abs(a) ((a>0)?a:-a)

const int32_t cos_tb[1024] = {
1024, 1024, 1024, 1024, 1024, 1024, 1023, 1023, 1023, 1022, 1022, 1022, 1021, 1021, 1020, 1020, 
1019, 1018, 1018, 1017, 1016, 1016, 1015, 1014, 1013, 1012, 1011, 1010, 1009, 1008, 1007, 1006, 
1004, 1003, 1002, 1000, 999, 998, 996, 995, 993, 992, 990, 989, 987, 985, 983, 982, 
980, 978, 976, 974, 972, 970, 968, 966, 964, 962, 960, 958, 955, 953, 951, 948, 
946, 944, 941, 939, 936, 934, 931, 928, 926, 923, 920, 917, 915, 912, 909, 906, 
903, 900, 897, 894, 891, 888, 885, 882, 878, 875, 872, 868, 865, 862, 858, 855, 
851, 848, 844, 841, 837, 834, 830, 826, 822, 819, 815, 811, 807, 803, 799, 796, 
792, 788, 784, 779, 775, 771, 767, 763, 759, 755, 750, 746, 742, 737, 733, 729, 
724, 720, 715, 711, 706, 702, 697, 692, 688, 683, 678, 674, 669, 664, 659, 654, 
650, 645, 640, 635, 630, 625, 620, 615, 610, 605, 600, 595, 590, 584, 579, 574, 
569, 564, 558, 553, 548, 543, 537, 532, 526, 521, 516, 510, 505, 499, 494, 488, 
483, 477, 472, 466, 460, 455, 449, 443, 438, 432, 426, 421, 415, 409, 403, 398, 
392, 386, 380, 374, 369, 363, 357, 351, 345, 339, 333, 327, 321, 315, 309, 303, 
297, 291, 285, 279, 273, 267, 261, 255, 249, 243, 237, 230, 224, 218, 212, 206, 
200, 194, 187, 181, 175, 169, 163, 156, 150, 144, 138, 132, 125, 119, 113, 107, 
100, 94, 88, 82, 75, 69, 63, 57, 50, 44, 38, 31, 25, 19, 13, 6, 
0, -6, -13, -19, -25, -31, -38, -44, -50, -57, -63, -69, -75, -82, -88, -94, 
-100, -107, -113, -119, -125, -132, -138, -144, -150, -156, -163, -169, -175, -181, -187, -194, 
-200, -206, -212, -218, -224, -230, -237, -243, -249, -255, -261, -267, -273, -279, -285, -291, 
-297, -303, -309, -315, -321, -327, -333, -339, -345, -351, -357, -363, -369, -374, -380, -386, 
-392, -398, -403, -409, -415, -421, -426, -432, -438, -443, -449, -455, -460, -466, -472, -477, 
-483, -488, -494, -499, -505, -510, -516, -521, -526, -532, -537, -543, -548, -553, -558, -564, 
-569, -574, -579, -584, -590, -595, -600, -605, -610, -615, -620, -625, -630, -635, -640, -645, 
-650, -654, -659, -664, -669, -674, -678, -683, -688, -692, -697, -702, -706, -711, -715, -720, 
-724, -729, -733, -737, -742, -746, -750, -755, -759, -763, -767, -771, -775, -779, -784, -788, 
-792, -796, -799, -803, -807, -811, -815, -819, -822, -826, -830, -834, -837, -841, -844, -848, 
-851, -855, -858, -862, -865, -868, -872, -875, -878, -882, -885, -888, -891, -894, -897, -900, 
-903, -906, -909, -912, -915, -917, -920, -923, -926, -928, -931, -934, -936, -939, -941, -944, 
-946, -948, -951, -953, -955, -958, -960, -962, -964, -966, -968, -970, -972, -974, -976, -978, 
-980, -982, -983, -985, -987, -989, -990, -992, -993, -995, -996, -998, -999, -1000, -1002, -1003, 
-1004, -1006, -1007, -1008, -1009, -1010, -1011, -1012, -1013, -1014, -1015, -1016, -1016, -1017, -1018, -1018, 
-1019, -1020, -1020, -1021, -1021, -1022, -1022, -1022, -1023, -1023, -1023, -1024, -1024, -1024, -1024, -1024, 
-1024, -1024, -1024, -1024, -1024, -1024, -1023, -1023, -1023, -1022, -1022, -1022, -1021, -1021, -1020, -1020, 
-1019, -1018, -1018, -1017, -1016, -1016, -1015, -1014, -1013, -1012, -1011, -1010, -1009, -1008, -1007, -1006, 
-1004, -1003, -1002, -1000, -999, -998, -996, -995, -993, -992, -990, -989, -987, -985, -983, -982, 
-980, -978, -976, -974, -972, -970, -968, -966, -964, -962, -960, -958, -955, -953, -951, -948, 
-946, -944, -941, -939, -936, -934, -931, -928, -926, -923, -920, -917, -915, -912, -909, -906, 
-903, -900, -897, -894, -891, -888, -885, -882, -878, -875, -872, -868, -865, -862, -858, -855, 
-851, -848, -844, -841, -837, -834, -830, -826, -822, -819, -815, -811, -807, -803, -799, -796, 
-792, -788, -784, -779, -775, -771, -767, -763, -759, -755, -750, -746, -742, -737, -733, -729, 
-724, -720, -715, -711, -706, -702, -697, -692, -688, -683, -678, -674, -669, -664, -659, -654, 
-650, -645, -640, -635, -630, -625, -620, -615, -610, -605, -600, -595, -590, -584, -579, -574, 
-569, -564, -558, -553, -548, -543, -537, -532, -526, -521, -516, -510, -505, -499, -494, -488, 
-483, -477, -472, -466, -460, -455, -449, -443, -438, -432, -426, -421, -415, -409, -403, -398, 
-392, -386, -380, -374, -369, -363, -357, -351, -345, -339, -333, -327, -321, -315, -309, -303, 
-297, -291, -285, -279, -273, -267, -261, -255, -249, -243, -237, -230, -224, -218, -212, -206, 
-200, -194, -187, -181, -175, -169, -163, -156, -150, -144, -138, -132, -125, -119, -113, -107, 
-100, -94, -88, -82, -75, -69, -63, -57, -50, -44, -38, -31, -25, -19, -13, -6, 
0, 6, 13, 19, 25, 31, 38, 44, 50, 57, 63, 69, 75, 82, 88, 94, 
100, 107, 113, 119, 125, 132, 138, 144, 150, 156, 163, 169, 175, 181, 187, 194, 
200, 206, 212, 218, 224, 230, 237, 243, 249, 255, 261, 267, 273, 279, 285, 291, 
297, 303, 309, 315, 321, 327, 333, 339, 345, 351, 357, 363, 369, 374, 380, 386, 
392, 398, 403, 409, 415, 421, 426, 432, 438, 443, 449, 455, 460, 466, 472, 477, 
483, 488, 494, 499, 505, 510, 516, 521, 526, 532, 537, 543, 548, 553, 558, 564, 
569, 574, 579, 584, 590, 595, 600, 605, 610, 615, 620, 625, 630, 635, 640, 645, 
650, 654, 659, 664, 669, 674, 678, 683, 688, 692, 697, 702, 706, 711, 715, 720, 
724, 729, 733, 737, 742, 746, 750, 755, 759, 763, 767, 771, 775, 779, 784, 788, 
792, 796, 799, 803, 807, 811, 815, 819, 822, 826, 830, 834, 837, 841, 844, 848, 
851, 855, 858, 862, 865, 868, 872, 875, 878, 882, 885, 888, 891, 894, 897, 900, 
903, 906, 909, 912, 915, 917, 920, 923, 926, 928, 931, 934, 936, 939, 941, 944, 
946, 948, 951, 953, 955, 958, 960, 962, 964, 966, 968, 970, 972, 974, 976, 978, 
980, 982, 983, 985, 987, 989, 990, 992, 993, 995, 996, 998, 999, 1000, 1002, 1003, 
1004, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1016, 1017, 1018, 1018, 
1019, 1020, 1020, 1021, 1021, 1022, 1022, 1022, 1023, 1023, 1023, 1024, 1024, 1024, 1024, 1024, 
};

int32_t mycos(int32_t a)
{
	return cos_tb[1023&a];
}

int32_t mysin(int32_t a)
{
	return cos_tb[1023&(a+3*MY_PI/2)];
}

void reg_init(struct pi_reg_state *s, uint32_t ki, uint32_t kp)
{
	s->ki = ki;
	s->kp = kp;
	s->a = 0;
	s->y = 0;
}

void reg_update(struct pi_reg_state *s, int32_t e, int32_t fs)
{
	int32_t a = s->a;
	int32_t d = s->ki*e;
	
	// will accumulator grow up?
	if(fs) if( ((a>0)&&(d>0))||((a<0)&&(d<0)) ) d = 0;

	a += d;
	s->y = e*s->kp + a;
	s->a = a;
	
	//s->y = 1024*e + s->a;
	//s->a = s->y - 782*e;
}

//extern int32_t dot3(int32_t *a, int32_t *b);
//extern void abc_to_dq(int32_t *abc, int32_t *dq, int32_t angle);
//extern void dq_to_abc(int32_t *abc, int32_t *dq, int32_t angle);


static inline int32_t dot3(int32_t *a, int32_t *b)
{
	return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}



void abc_to_dq(int32_t *abc, int32_t *dq, int32_t angle)
{
	int32_t ct[3] = {	cos_tb[angle], 
						cos_tb[1023&(angle+(4*512)/3)], 
						cos_tb[1023&(angle+(2*512)/3)] };
	int32_t st[3] = {	cos_tb[1023&(3*512/2+angle)], 
						cos_tb[1023&(3*512/2+angle+(4*512)/3)], 
						cos_tb[1023&(3*512/2+angle+2*512/3)] };

	dq[0] = (dot3(abc, ct)) >> 10;	
	dq[1] = (-dot3(abc, st)) >> 10;
}


void dq_to_abc(int32_t *abc, int32_t *dq, int32_t angle)
{
	abc[0] = (dq[0]*cos_tb[angle] 				- dq[1]*cos_tb[1023&(angle+3*512/2)]) >> 20;
	abc[1] = (dq[0]*cos_tb[1023&(angle+4*512/3)] - dq[1]*cos_tb[1023&(angle+4*512/3+3*512/2)]) >> 20;
	abc[2] = (dq[0]*cos_tb[1023&(angle+2*512/3)] - dq[1]*cos_tb[1023&(angle+2*512/3+3*512/2)]) >> 20;
}

// calc magnitude and angle of 2Dvector using CORDIC algorithm
void cord_atan(int32_t *v, int32_t *ang, int32_t *mag)
{
	const int32_t AngTable[] = {128, 76, 40, 20, 10, 5, 3, 1};	// angles for those tg =0.5,0.25 etc
	const int32_t kc[] = {724,  648, 628,  623,  623,  622,  622,  622}; // mag correction 1/cos(ang)
	int32_t SumAngle = 0; 
	int i = 0;
	int x, y, x1, y1;
	int ns = 0;

	x = abs(v[0]);
	y = v[1];

	for(i = 0; i < 8; i++)
	{		
		ns++;
		
		x1 = x;
		y1 = y;
			
		if(y > 0){
			x = x1 + (y1 >> i); 
			y = y1 - (x1 >> i); 
			SumAngle = SumAngle + AngTable[i]; 
		}else{
			x = x1 - (y1 >> i); 
			y = y1 + (x1 >> i); 
			SumAngle = SumAngle - AngTable[i]; 
		}
		if(y == 0) break;
	}
	
	if(v[0] < 0) SumAngle = MY_PI-SumAngle;		
	if(SumAngle < 0) SumAngle += 2*MY_PI;	
	
	*ang = SumAngle;
	*mag = (kc[ns-1]*x) >> 10;
}

int32_t sinpwm(int32_t *abc, int32_t *dq, int32_t phase)
{
	int32_t fs = 0;
	int32_t mag;
	int32_t ang;
	cord_atan(dq, &ang, &mag);
	
	mag = mag >> 10;
	int32_t phi = 1023&(phase + ang);
	
	if(mag > MAXPWM) {
		mag = MAXPWM;
		fs = 1;
	}
	else fs = 0;

	//dq_to_abc(abc, dq, phase);
	abc[0] = mag*mycos( 1023&(phi) ) >> 10;
	abc[1] = -mag*mycos( 1023&(MY_PI/3+phi) ) >> 10;
	abc[2] = -mag*mycos( 1023&(2*MY_PI+MY_PI/3-phi) ) >> 10;

	return fs;	
}

int32_t svpwm(int32_t *abc, int32_t *dq, int32_t phase)
{
	int32_t fs = 0;
	int32_t mag;
	int32_t ang;
	cord_atan(dq, &ang, &mag);
	
	mag = mag >> 10;

	if(mag > MAXPWM) {
		mag = MAXPWM;
		fs = 1;
	}
	else fs = 0;

	int32_t phi = 1023&(phase + ang);			
	int32_t ns = (phi*6) >> 10;	 // get the sector number
	int32_t r1;
	int32_t r2;
	
	switch(ns){
		case 0:
		r1 = mag*mysin(7*MY_PI/3-phi) >> 10;
		r2 = mag*mysin(phi) >> 10;
		
		abc[0] = r1+r2;
		abc[1] = -r1+r2;
		abc[2] = -r1-r2;			
		break;
		
		case 1:
		phi -= MY_PI/3;
		r1 = mag*mysin(7*MY_PI/3-phi) >> 10;
		r2 = mag*mysin(phi) >> 10;
		
		abc[0] = r1-r2;
		abc[1] = r1+r2;
		abc[2] = -r1-r2;		
		break;
		
		case 2:
		phi -= 2*MY_PI/3;
		r1 = mag*mysin(7*MY_PI/3-phi) >> 10;
		r2 = mag*mysin(phi) >> 10;
		
		abc[0] = -r1-r2;
		abc[1] = r1+r2;
		abc[2] = -r1+r2;
		break;
		
		case 3:
		phi -= 3*MY_PI/3;
		r1 = mag*mysin(7*MY_PI/3-phi) >> 10;
		r2 = mag*mysin(phi) >> 10;
		
		abc[0] = -r1-r2;
		abc[1] = r1-r2;
		abc[2] = r1+r2;		
		break;
		
		case 4:
		phi -= 4*MY_PI/3;
		r1 = mag*mysin(7*MY_PI/3-phi) >> 10;
		r2 = mag*mysin(phi) >> 10;
		
		abc[0] = -r1+r2;
		abc[1] = -r1-r2;
		abc[2] = r1+r2;	
		break;
		
		case 5:
		phi -= 5*MY_PI/3;
		r1 = mag*mysin(7*MY_PI/3-phi) >> 10;
		r2 = mag*mysin(phi) >> 10;
		
		abc[0] = +r1+r2;
		abc[1] = -r1-r2;
		abc[2] = r1-r2;
		break;
	}
	
	return fs;
}

static int32_t enc1 = 0;
static int32_t enc2 = 0;

void encoder_init(int32_t s)
{
	enc1 = s;
	enc2 = s;
}

int32_t get_speed(int32_t enc, int32_t *pos)
{
	int32_t denc;
	int32_t rate = 60*(120000000/5/1024/8);
	
	denc = (enc-enc2);
	enc2 = enc1;
	enc1 = enc;
	if(abs(denc) > 1000){
		if(denc < 0) denc += 4096;
		else denc -= 4096;
	}		
	
	*pos += denc;
	
	//return ((denc>>1)*rate)>>12;
	return (denc*rate)>>13;
} 

int32_t lerr_filter(int32_t x)
{
	static int32_t j = 0;
	static int32_t a = 0;
	static int32_t b[256];
	
	j = (j+1)&(256-1);
	a = a-b[j]+x;
	b[j] = x;
	
	return a;
}


int32_t lpos_filter(int32_t x)
{
	static int32_t j = 0;
	static int32_t a = 0;
	static int32_t b[16];
	
	j = (j+1)&(16-1);
	a = a-b[j]+x;
	b[j] = x;
	
	return a>>4;
}
/*
int32_t lref_filter(int32_t x, int32_t a)
{
	static int32_t j = 0;
	//static int32_t a = 0;
	static int32_t b[128];
	
	j = (j+1)&(128-1);
	a = a-b[j]+x;
	b[j] = x;
	
	return a;
}
*/

uint32_t get_mag(int32_t *v)
{
	return (abs(v[0]) + abs(v[1]));
}

#define MFORDER 1024
int32_t mfilter(int32_t x, int32_t a)
{
	static int32_t j = 0;
	//static int32_t a = 0;
	static int32_t b[MFORDER]; // = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};	
	
	j = (j+1)&(MFORDER-1);
	a = a-b[j]+x;
	b[j] = x;
	
	return a;
}


int32_t rfilter1(int32_t x)
{
	static int32_t x1=0;
	static int32_t x2=0;
	static int32_t y1=0;
	static int32_t y2=0;	

	int32_t y = (-RF_A12*y1 - RF_A13*y2 + RF_B11*x + RF_B12*x1 + RF_B13*x2) >> RF_SHIFTA;
	x2 = x1; x1 = x;
	y2 = y1; y1 = y;
	
	return y >> (RF_SHIFTB - RF_SHIFTA);
}

int32_t rfilter2(int32_t x)
{
	static int32_t x1=0;
	static int32_t x2=0;
	static int32_t y1=0;
	static int32_t y2=0;	

	int32_t y = (-RF_A22*y1 - RF_A23*y2 + RF_B21*x + RF_B22*x1 + RF_B23*x2) >> RF_SHIFTA;
	x2 = x1; x1 = x;
	y2 = y1; y1 = y;
	
	return y >> (RF_SHIFTB - RF_SHIFTA);
}

int32_t prefilter(int32_t xk)
{
	const int32_t a2 = 958;
	const int32_t b1 = 66;
	static int32_t yk1 = 0;
	int32_t yk = 0;
	
	yk = b1*xk + ((a2*yk1)>>10);
	yk1 = yk;
	
	return yk >> 10;
}
